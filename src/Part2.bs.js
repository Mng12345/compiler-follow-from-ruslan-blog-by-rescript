// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var ReadlineSync = require("./ReadlineSync.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var NotToken = /* @__PURE__ */Caml_exceptions.create("Part2.Token.NotToken");

var Operator = {};

var Token = {
  NotToken: NotToken,
  Operator: Operator
};

var TokenNode = {};

var WrongExpression = /* @__PURE__ */Caml_exceptions.create("Part2.Interpreter.WrongExpression");

var NeverHappenedInFilteredTokens = /* @__PURE__ */Caml_exceptions.create("Part2.Interpreter.NeverHappenedInFilteredTokens");

var NoTokens = /* @__PURE__ */Caml_exceptions.create("Part2.Interpreter.NoTokens");

function make(text) {
  return {
          text: text,
          pos: 0,
          currentToken: /* Eof */0
        };
}

function getNextSingleToken(interpreter) {
  if (interpreter.pos > (interpreter.text.length - 1 | 0)) {
    interpreter.pos = interpreter.pos + 1 | 0;
    return /* Eof */0;
  }
  var $$char = interpreter.text.charAt(interpreter.pos);
  switch ($$char) {
    case " " :
        interpreter.pos = interpreter.pos + 1 | 0;
        return /* Whitespace */1;
    case "*" :
        interpreter.pos = interpreter.pos + 1 | 0;
        return {
                TAG: /* Operator */1,
                _0: /* Multiply */2
              };
    case "+" :
        interpreter.pos = interpreter.pos + 1 | 0;
        return {
                TAG: /* Operator */1,
                _0: /* Plus */0
              };
    case "-" :
        interpreter.pos = interpreter.pos + 1 | 0;
        return {
                TAG: /* Operator */1,
                _0: /* Subtract */1
              };
    case "/" :
        interpreter.pos = interpreter.pos + 1 | 0;
        return {
                TAG: /* Operator */1,
                _0: /* Divide */3
              };
    case "0" :
    case "1" :
    case "2" :
    case "3" :
    case "4" :
    case "5" :
    case "6" :
    case "7" :
    case "8" :
    case "9" :
        break;
    default:
      throw {
            RE_EXN_ID: NotToken,
            Error: new Error()
          };
  }
  interpreter.pos = interpreter.pos + 1 | 0;
  return {
          TAG: /* Integer */0,
          _0: Belt_Int.fromString($$char)
        };
}

function getNextToken(interpreter) {
  var _left;
  while(true) {
    var left = _left;
    var right = getNextSingleToken(interpreter);
    if (left !== undefined) {
      if (typeof left === "number") {
        if (left === /* Eof */0) {
          return /* Eof */0;
        }
        
      } else if (left.TAG === /* Integer */0 && typeof right !== "number" && right.TAG === /* Integer */0) {
        _left = {
          TAG: /* Integer */0,
          _0: Math.imul(left._0, 10) + right._0 | 0
        };
        continue ;
      }
      interpreter.pos = interpreter.pos - 1 | 0;
      return left;
    }
    if (right === 0) {
      return /* Eof */0;
    }
    _left = right;
    continue ;
  };
}

function extractTokens(interpreter) {
  var extractTokens_ = function (interpreter, _list) {
    while(true) {
      var list = _list;
      var token = getNextToken(interpreter);
      if (typeof token === "number") {
        if (token === 0) {
          return Belt_List.add(list, token);
        }
        continue ;
      }
      var list$1 = Belt_List.add(list, token);
      _list = list$1;
      continue ;
    };
  };
  return Belt_List.reverse(extractTokens_(interpreter, /* [] */0));
}

function execute(tokens) {
  var makeNode = function (_rootNode, _tokens) {
    while(true) {
      var tokens = _tokens;
      var rootNode = _rootNode;
      if (!tokens) {
        return rootNode;
      }
      var t = tokens.tl;
      var h = tokens.hd;
      var match = rootNode.value;
      if (typeof match === "number") {
        if (match === /* Eof */0) {
          throw {
                RE_EXN_ID: NeverHappenedInFilteredTokens,
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: NeverHappenedInFilteredTokens,
              Error: new Error()
            };
      } else if (match.TAG === /* Integer */0) {
        if (typeof h === "number") {
          if (h === /* Eof */0) {
            return rootNode;
          }
          throw {
                RE_EXN_ID: NeverHappenedInFilteredTokens,
                Error: new Error()
              };
        } else {
          if (h.TAG === /* Integer */0) {
            throw {
                  RE_EXN_ID: NeverHappenedInFilteredTokens,
                  Error: new Error()
                };
          }
          _tokens = t;
          _rootNode = {
            value: h,
            left: rootNode.value,
            right: undefined
          };
          continue ;
        }
      } else {
        if (typeof h === "number") {
          throw {
                RE_EXN_ID: NeverHappenedInFilteredTokens,
                Error: new Error()
              };
        }
        if (h.TAG === /* Integer */0) {
          var right = h._0;
          var left = rootNode.left;
          if (left !== undefined) {
            if (typeof left === "number") {
              throw {
                    RE_EXN_ID: NeverHappenedInFilteredTokens,
                    Error: new Error()
                  };
            }
            if (left.TAG === /* Integer */0) {
              var left$1 = left._0;
              var tmp;
              switch (match._0) {
                case /* Plus */0 :
                    tmp = {
                      value: {
                        TAG: /* Integer */0,
                        _0: left$1 + right | 0
                      },
                      left: undefined,
                      right: undefined
                    };
                    break;
                case /* Subtract */1 :
                    tmp = {
                      value: {
                        TAG: /* Integer */0,
                        _0: left$1 - right | 0
                      },
                      left: undefined,
                      right: undefined
                    };
                    break;
                case /* Multiply */2 :
                    tmp = {
                      value: {
                        TAG: /* Integer */0,
                        _0: Math.imul(left$1, right)
                      },
                      left: undefined,
                      right: undefined
                    };
                    break;
                case /* Divide */3 :
                    tmp = {
                      value: {
                        TAG: /* Integer */0,
                        _0: Caml_int32.div(left$1, right)
                      },
                      left: undefined,
                      right: undefined
                    };
                    break;
                
              }
              _tokens = t;
              _rootNode = tmp;
              continue ;
            }
            throw {
                  RE_EXN_ID: NeverHappenedInFilteredTokens,
                  Error: new Error()
                };
          } else {
            throw {
                  RE_EXN_ID: NeverHappenedInFilteredTokens,
                  Error: new Error()
                };
          }
        } else {
          throw {
                RE_EXN_ID: NeverHappenedInFilteredTokens,
                Error: new Error()
              };
        }
      }
    };
  };
  if (tokens) {
    var v = makeNode({
          value: tokens.hd,
          left: undefined,
          right: undefined
        }, tokens.tl).value;
    if (typeof v === "number") {
      throw {
            RE_EXN_ID: NeverHappenedInFilteredTokens,
            Error: new Error()
          };
    }
    if (v.TAG === /* Integer */0) {
      return v._0;
    }
    throw {
          RE_EXN_ID: NeverHappenedInFilteredTokens,
          Error: new Error()
        };
  } else {
    throw {
          RE_EXN_ID: NoTokens,
          Error: new Error()
        };
  }
}

function expr(interpreter) {
  return execute(Belt_List.keep(extractTokens(interpreter), (function (token) {
                    if (typeof token === "number") {
                      return token === 0;
                    } else {
                      return true;
                    }
                  })));
}

var Interpreter = {
  WrongExpression: WrongExpression,
  NeverHappenedInFilteredTokens: NeverHappenedInFilteredTokens,
  NoTokens: NoTokens,
  make: make,
  getNextSingleToken: getNextSingleToken,
  getNextToken: getNextToken,
  extractTokens: extractTokens,
  execute: execute,
  expr: expr
};

function main(param) {
  while(true) {
    try {
      var text = ReadlineSync.question("calc>");
      var interpreter = make(text);
      var value = expr(interpreter);
      console.log(value);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      console.log("error: ", exn);
    }
  };
  
}

main(undefined);

exports.Token = Token;
exports.TokenNode = TokenNode;
exports.Interpreter = Interpreter;
exports.main = main;
/*  Not a pure module */
